# Chapter5
<br>

## 📌문제4

### 클로저의 정의에 대해 서술해보세요

<br>

### 답안 작성

```
함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수
이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수
자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수
```

<br>

## 📌문제5

### 다음 코드의 실행 결과를 작성하세요.

```js
function counting() {
  let i = 0;
  for (i = 0; i < 5; i += 1) {
    setTimeout(function () {
      console.log(i);
    }, i * 1000);
  }
}

counting();
```

### 답안 작성

```
5
5
5
5
5
```

```
setTimeout의 대기시간이 끝나 콜백함수가 실행되는 시점에는 루프가 종료되어 i는 5가 되어있습니다.
콜백함수는 클로저이기 때문에 상위 i값을 가져오고, 이미 i값은 5까지 증가한 상태이기 때문에 출력 결과가 다음과 같습니다.
```

## 📌문제6

### 문제2의 실행 결과가 `0 1 2 3 4`가 되도록 `블록 스코프` 개념을 이용하여 코드를 수정해보세요.

<br>

### 답안 작성

```js
// 블록 스코프
function counting() {
  // for 내부에 let 변수 선언한 것과 동일
  for (let i = 0; i < 5; i += 1) {
    setTimeout(function () {
      console.log(i);
    }, i * 100);
  }
}

counting();
// let은 블록 수준 스코프이기 때문에 매 루프마다 클로저가 생성된다.
// 매 반복마다 새로운 i가 선언되고, 반복이 끝난 이후의 값으로 초기화된다.
```

<br>



## 📌문제7
클로저를 사용하면 메모리 소모가 일어나는데, 이때 메모리를 어떻게 관리하는지 서술해주세요.

```
필요성이 사라진 시점에 참조카운터를 0으로 만들어 준다. 
참조 카운터를 0으로 만드는 방법은 식별자에 참조형이 아닌 기본형 데이터(보통 null이나 undefined)를 할당하면 된다. 
```


## 📌문제8
다음의 실행 결과를 써주세요.

```
var createObj = function(){
    var a = 0;
    var b = 1;
    return {
        get b(){
            return b;
        }
    };
}

var obj = createObj();
console.log(obj.a);
console.log(obj.b);
obj.a = 1;
obj.b = 2;
console.log(obj.a);
console.log(obj.b);
```

```javascript
undefined
1
1
1

obj.a는 접근이 불가능하기 때문에 undifined 가 나오고, obj.b는 getter함수로 읽기 접근이 가능해 1이 나온다.
obj.a를 할당해주고 1이라는 값을 넣어주면 객체 자체에서 추가, 삭제가 가능하기 때문에 a라는 값이 할당된다. obj.b는 set 함수가 없기 때문에 값이 변경되지 않는다. 이렇게 obj.a 같이 마음대로 객체에 요소를 추가하는 것 등 객체의 잘못된 이용을 막으려면 Object.freeze를 해주면 된다.

// 객체 변경을 막은 코드
var createObj = function(){
    var a = 0;
    var b = 1;
    const public = Object.freeze( {
        get b(){
            return b;
        }
    });
    return public;

}
```


## 📌문제9

다음의 실행 결과를 써 주세요.

```javascript
var curry5 = func => a => b => c => d => e => func(a, b, c, d, e);
var getMax = curry5(Math.max);
console.log(getMax(1)(2)(3));
var getMax2 = getMax(1)(2)(3);
console.log(getMax2(4)(5));
```

```
[Function (anonymous)]
5
커링함수에 관한 문제이다. 커링함수는 함수가 중첩되어 마지막 인자가 전달되기 전 까지는 원본함수가 실행되지 않고, 만약 리턴 시 함수가 리턴된다.(자체 실행 결과)
p142
```
