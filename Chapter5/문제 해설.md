# Chapter5
<br>

## 📌문제4

### 클로저의 정의에 대해 서술해보세요

<br>

### 답안 작성

```
함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수
이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수
자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수
```

<br>

## 📌문제5

### 다음 코드의 실행 결과를 작성하세요.

```js
function counting() {
  let i = 0;
  for (i = 0; i < 5; i += 1) {
    setTimeout(function () {
      console.log(i);
    }, i * 1000);
  }
}

counting();
```

### 답안 작성

```
5
5
5
5
5
```

```
setTimeout의 대기시간이 끝나 콜백함수가 실행되는 시점에는 루프가 종료되어 i는 5가 되어있습니다.
콜백함수는 클로저이기 때문에 상위 i값을 가져오고, 이미 i값은 5까지 증가한 상태이기 때문에 출력 결과가 다음과 같습니다.
```

## 📌문제6

### 문제2의 실행 결과가 `0 1 2 3 4`가 되도록 `블록 스코프` 개념을 이용하여 코드를 수정해보세요.

<br>

### 답안 작성

```js
// 블록 스코프
function counting() {
  // for 내부에 let 변수 선언한 것과 동일
  for (let i = 0; i < 5; i += 1) {
    setTimeout(function () {
      console.log(i);
    }, i * 100);
  }
}

counting();
// let은 블록 수준 스코프이기 때문에 매 루프마다 클로저가 생성된다.
// 매 반복마다 새로운 i가 선언되고, 반복이 끝난 이후의 값으로 초기화된다.
```

<br>
