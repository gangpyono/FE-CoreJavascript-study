# Chapter5
<br>

## 📌문제4

### 클로저의 정의에 대해 서술해보세요

<br>

### 답안 작성

```
함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수
이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수
자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수
```

<br>

## 📌문제5

### 다음 코드의 실행 결과를 작성하세요.

```j
function counting() {
  let i = 0;
  for (i = 0; i < 5; i += 1) {
    setTimeout(function () {
      console.log(i);
    }, i * 1000);
  }
}

counting();
```

### 답안 작성

```
5
5
5
5
5
```

```
setTimeout의 대기시간이 끝나 콜백함수가 실행되는 시점에는 루프가 종료되어 i는 5가 되어있습니다.
콜백함수는 클로저이기 때문에 상위 i값을 가져오고, 이미 i값은 5까지 증가한 상태이기 때문에 출력 결과가 다음과 같습니다.
```

## 📌문제6

### 문제2의 실행 결과가 `0 1 2 3 4`가 되도록 `블록 스코프` 개념을 이용하여 코드를 수정해보세요.

<br>

### 답안 작성

```js
// 블록 스코프
function counting() {
  // for 내부에 let 변수 선언한 것과 동일
  for (let i = 0; i < 5; i += 1) {
    setTimeout(function () {
      console.log(i);
    }, i * 100);
  }
}

counting();
// let은 블록 수준 스코프이기 때문에 매 루프마다 클로저가 생성된다.
// 매 반복마다 새로운 i가 선언되고, 반복이 끝난 이후의 값으로 초기화된다.
```

<br>



## 📌문제7
클로저를 사용하면 메모리 소모가 일어나는데, 이때 메모리를 어떻게 관리하는지 서술해주세요.

### 답안 작성
```
필요성이 사라진 시점에 참조카운터를 0으로 만들어 준다. 
참조 카운터를 0으로 만드는 방법은 식별자에 참조형이 아닌 기본형 데이터(보통 null이나 undefined)를 할당하면 된다. 
```
p123


## 📌문제8
다음의 실행 결과를 써주세요.

```js
var createObj = function(){
    var a = 0;
    var b = 1;
    return {
        get b(){
            return b;
        }
    };
}

var obj = createObj();
console.log(obj.a);
console.log(obj.b);
obj.a = 1;
obj.b = 2;
console.log(obj.a);
console.log(obj.b);
```
### 답안 작성
```javascript
undefined
1
1
1
```

```
obj.a는 접근이 불가능하기 때문에 undifined 가 나오고, obj.b는 getter함수로 읽기 접근이 가능해 1이 나온다.
obj.a를 할당해주고 1이라는 값을 넣어주면 객체 자체에서 추가, 삭제가 가능하기 때문에 a라는 값이 할당된다.
obj.b는 set 함수가 없기 때문에 값이 변경되지 않는다. 
이렇게 obj.a 같이 마음대로 객체에 요소를 추가하는 것 등 객체의 잘못된 이용을 막으려면 Object.freeze를 해주면 된다.
```

```js
// 객체 변경을 막은 코드
var createObj = function(){
    var a = 0;
    var b = 1;
    const public = Object.freeze( {
        get b(){
            return b;
        }
    });
    return public;

}
```
p132, 133


## 📌문제9

다음의 실행 결과를 써 주세요.

```javascript
var curry5 = func => a => b => c => d => e => func(a, b, c, d, e);
var getMax = curry5(Math.max);
console.log(getMax(1)(2)(3));
var getMax2 = getMax(1)(2)(3);
console.log(getMax2(4)(5));
```
### 답안 작성
```
[Function (anonymous)]
5
커링함수에 관한 문제이다. 커링함수는 함수가 중첩되어 마지막 인자가 전달되기 전 까지는 원본함수가 실행되지 않고, 
만약 리턴 시 함수가 리턴된다.(자체 실행 결과)
p142
```


## 📌문제10

f1의 실행이 종료된이후의 gc수거대상인 변수는? (다중선택 가능.)

```javascript
      const f1 = function () {
        let a = 0;
        let b = 1;
        const obj = { name: "Core" };

        const f2 = function () {
          a += 1;

          return a;
        };

        return f2;
      };

      const f3 = f1(); //  f1이 종료된이후의 gc수거대상인 변수는? b,obj,f2
```

```
- b,obj,f2
- a를 제외한 변수는 f1의 실행컨텍스트가 종료될때 참조카운트가 0가되기떄문에 gc의 수거대상이 된다.(120p.)
```


## 📌문제11

커링함수와 부분적용함수의 차이점은?

```html
       커링함수는 여러개의 인자를 받는 함수를 하나의 인자만을 받는함수로 나눠서 순차적으로 호출 될 수 있게 체인 형태로 구성하는것을 말한다.
       한번의 하나의 인자만을 전달하는것을 원칙.
       마지막 인자를 전달받기전까진 원본함수가 실행되지 않는다.

       부분적용함수는 여러개의 인자를 한번에 전달 할 수 있다.
       부분적용된 함수를 실행할떄 원본함수가 무조건 실행된다.
```

## 📌문제12

클로저란?

```html
어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상.

