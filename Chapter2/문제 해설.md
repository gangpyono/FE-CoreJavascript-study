# Chapter2

## 문제1
### 정답 및 해설 (관련 주제 : 함수 선언식과 표현식)
```
test1() 의 출력값 : (1) : javascript
test2() 의 출력값 : (2) : TypeError : **** is not a function
test3() 의 출력값 : (3) : ReferenceError : **** is not defined
```
test1 함수 작성 방식은 `함수 선언문`이라고 하고, test2, test3 함수 작성 방식은 `함수 표현식`이라고 합니다.   
실행 컨텍스트의 정보 수집과정(Hoisting)에서 변수의 선언과 함수 선언을 코드 실행 전에 수집합니다. 따라서 test1() 실행했을 때는 이미 test1 함수 정보를 알고 있어서 'javascript'라고 출력됩니다.   
하지만 함수 표현식으로 작성된 경우 변수(또는 상수)에 할당을 해서 사용하므로 실행 컨텍스트의 정보 수집과정에 대상이 되지 않습니다. 따라서 함수를 할당하기 전에 함수를 호출한다면 원하는 결과를 얻을 수 없습니다.   
test2의 경우 변수 선언을 var로 했기 때문에 test2 변수 생성시 초기화 단계까지 이루어진다. 따라서 test2의 값으로 undefined가 들어있고, 이 상태에서 함수를 호출하려고하니 JS Engine에서는 test2 변수가 undefined 타입이므로 TypeError를 출력합니다.   
test3의 경우 변수 선언을 let으로 
test2와 test3의 차이점은 변수 선언(var, let)에 있고, 그 중 변수 생성 단계에서 차이점을 정확히 알 수 있습니다. 변수 생성은 `선언 단계` → `초기화 단계` → `할당 단계`로 이루어져있습니다. 실행 컨텍스트의 정보 수집과정에서 var 변수는 선언과 초기화 단계가 동시에 이루어지므로 test2 변수값으로 undefined가 들어있습니다. 하지만 let 변수는 선언 단계까지만 진행되므로 변수값에 메모리 공간 확보 자체가 되어 있지않습니다. 따라서 var로 선언한 test2 함수 호출시 undefined와 function은 다른 타입이므로 TypeError를 출력하고, let으로 선언한 test3 함수 호출시 값은 물론 메모리 조차 없으므로 ReferenceError를 출력합니다.

- [🔗변수 호이스팅(Variable Hoisting) (poiemaweb 블로그)](https://poiemaweb.com/js-data-type-variable#23-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85variable-hoisting)
- [🔗호이스팅 (poiemaweb 블로그)](https://poiemaweb.com/js-data-type-variable#23-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85variable-hoisting)

<br>

## 문제2
### 정답 및 해설 (관련 주제 : 스코프)
```
#1 : [1, 2]
#2 : [10, 20]
#3 : [10, 20]
#4 : [10, 2]
#5 : [100, 2]
```
보통 문제 코드와 같이 코드를 작성하지 않지만 스코프에 대한 이해를 위해 작성했습니다. (해설 추가 예정)

<br>

## 문제3
### 정답 및 해설 (관련 주제 : 실행 컨텍스트)
```
미완료
```
- [VariableEnvironment는 왜 필요할까? (블로그)](https://sambalim.tistory.com/155)
