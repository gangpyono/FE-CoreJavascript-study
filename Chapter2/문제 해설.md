# Chapter2

## 📌문제1
### 다음 중 각 함수를 호출했을 때, 예상되는 출력값을 보기에서 고르시오.   
(실제로 세 함수를 동시에 호출하면 Error가 생기는 함수 이후로는 작동하지 않습니다. 문제 의도는 각 함수의 출력값이라는 점을 참고바랍니다.)
```js
test1();
test2();
test3();

function test1() {
	console.log('javascript');
}

var test2 = function() {
	console.log('javascript');
}

let test3 = function() {
	console.log('javascript');
}
```
### 보기
```
(1) : javascript
(2) : TypeError
(3) : ReferenceError
```
### 정답 및 해설 (관련 주제 : 함수 선언식과 표현식)
```
test1() 의 출력값 : (1) : javascript
test2() 의 출력값 : (2) : TypeError : **** is not a function
test3() 의 출력값 : (3) : ReferenceError : **** is not defined
```
test1 함수 작성 방식은 `함수 선언문`이라고 하고, test2, test3 함수 작성 방식은 `함수 표현식`이라고 합니다.   
실행 컨텍스트의 정보 수집과정(Hoisting)에서 변수의 선언과 함수 선언을 코드 실행 전에 수집합니다. 따라서 test1() 실행했을 때는 이미 test1 함수 정보를 알고 있어서 'javascript'라고 출력됩니다.   
하지만 함수 표현식으로 작성된 경우 변수(또는 상수)에 할당을 해서 사용하므로 실행 컨텍스트의 정보 수집과정에 대상이 되지 않습니다. 따라서 함수를 할당하기 전에 함수를 호출한다면 원하는 결과를 얻을 수 없습니다.   
test2의 경우 변수 선언을 var로 했기 때문에 test2 변수 생성시 초기화 단계까지 이루어진다. 따라서 test2의 값으로 undefined가 들어있고, 이 상태에서 함수를 호출하려고하니 JS Engine에서는 test2 변수가 undefined 타입이므로 TypeError를 출력합니다.   
test3의 경우 변수 선언을 let으로 
test2와 test3의 차이점은 변수 선언(var, let)에 있고, 그 중 변수 생성 단계에서 차이점을 정확히 알 수 있습니다. 변수 생성은 `선언 단계` → `초기화 단계` → `할당 단계`로 이루어져있습니다. 실행 컨텍스트의 정보 수집과정에서 var 변수는 선언과 초기화 단계가 동시에 이루어지므로 test2 변수값으로 undefined가 들어있습니다. 하지만 let 변수는 선언 단계까지만 진행되므로 변수값에 메모리 공간 확보 자체가 되어 있지않습니다. 따라서 var로 선언한 test2 함수 호출시 undefined와 function은 다른 타입이므로 TypeError를 출력하고, let으로 선언한 test3 함수 호출시 값은 물론 메모리 조차 없으므로 ReferenceError를 출력합니다.

- [🔗변수 호이스팅(Variable Hoisting) (poiemaweb 블로그)](https://poiemaweb.com/js-data-type-variable#23-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85variable-hoisting)
- [🔗호이스팅 (poiemaweb 블로그)](https://poiemaweb.com/js-data-type-variable#23-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85variable-hoisting)

<br>

## 📌문제2
### 다음 코드의 실행 결과를 작성하세요.
```js
function test() {
  var a = 1;
  let b = 2;
  console.log(`#1 : [${a}, ${b}]`);

  if(true) {
    var a = 10;
    let b = 20;
    console.log(`#2 : [${a}, ${b}]`);
    
    function ifFunction() {
      a = 100;
      b = 200;
    }
    console.log(`#3 : [${a}, ${b}]`);
  }
  console.log(`#4 : [${a}, ${b}]`);

  ifFunction();
  console.log(`#5 : [${a}, ${b}]`);
}

test();
```
### 정답 및 해설 (관련 주제 : 스코프)
```
#1 : [1, 2]
#2 : [10, 20]
#3 : [10, 20]
#4 : [10, 2]
#5 : [100, 2]
```
보통 문제 코드와 같이 코드를 작성하지 않지만 스코프에 대한 이해를 위해 작성했습니다. (해설 추가 예정)

<br>

## 📌문제3
### 교재에서는 다음과 같이 설명하고 있습니다.

> 실행 컨텍스트 는 VariableEnvironment, LexicalEnvironment, ThisBinding으로 이루어져있습니다. 실행 컴텍스트 생성시 VariableEnvironment에 정보를 담고 이것을 그대로 복사해서 LexicalEnvironment를 만듭니다. 이후 LexicalEnvironment를 주로 활용하게 됩니다.

### 그럼 생성시를 제외하고 VariableEnvironment는 어디에 사용되는 걸까요?
### 정답 및 해설 (관련 주제 : 실행 컨텍스트)
```
해설 작성 예정
```
- [🔗VariableEnvironment는 왜 필요할까? (블로그)](https://sambalim.tistory.com/155)


## 📌문제7
- OX 퀴즈
    1) X. Lexical Environment가 변경사항이 실시간으로 반영되고, Variable Environment가 초기 상태로 유지된다. p40
    2) O. 최상단의 공간은 코드 내부에서 별도의 실행명령이 없어도 브라우저에서 자동으로 실행하기 때문에 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다. p38
    3) O. outerEnvironment는 연결리스트 형태를 띄면서 자신이 선언된 시점의 LexicalEnvironment만 참조하기 때문에 가장 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근이 가능하다. p54

## 📌문제8
함수 선언문은 함수 전체를 호이스팅 하고, 변수를 사용해 함수 표현식을 사용한 경우에는 변수 선언부만 호이스팅 된다. 따라서 함수 표현식을 사용하면 함수 선언 상단의 코드에서 함수를 사용하지 못한다. p48

## 📌문제9
--output--
function b
'b'
undefined
1
'b'
1

p45, 54


