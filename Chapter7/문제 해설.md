# Chapter7

## 📌문제1

### 다음 중 관련 있는 설명끼리 짝지어 보세요.

```
(1) 클래스의 프로토타입 내부에 정의된 메서드
(2) 클래스에 직접 정의한 메서드
(3) 인스턴스가 마치 자신의 것처럼 호출할 수 있다.
(4) 인스턴스가 직접 호출할 수 없고 클래서에 의해서만 호출된다.
```
### 답안 작성
```
prototype method : (1), (3)
static method    : (2), (4)
```

<br>

## 📌문제2

### (1)의 실행결과가 180이 되도록 코드를 수정하세요. (코드는 수정된 부분만 작성하세요.)

```js
class Expenditure {
  constructor(name, jan, feb) {
    this.name = name;
    this.jan = jan;
    this.feb = feb;
  }
}

Expenditure.prototype.sum = function () {
  return this.jan + this.feb;
};

class UpdateExpenditure {
  constructor(name, jan, feb, mar) {
    super(name, jan, feb);
    this.mar = mar;
  }

  total() {
    return super.sum() + this.mar;
  }
}

let jieun = new UpdateExpenditure("jieun", 60, 70, 50);

console.log(jieun.total());
```

### 답안 작성
```js
class UpdateExpenditure extends Expenditure {
                     ...
}
```

<br>

## 📌문제3

### 다음 중 오류가 발생하는 것을 고르세요.

```js
class Expenditure {
  constructor(name, jan, feb) {
    this.name = name;
    this.jan = jan;
    this.feb = feb;
  }

  sum() {
    return this.jan + this.feb;
  }
}

class UpdateExpenditure extends Expenditure {
  constructor(name, jan, feb, mar) {
    super(name, jan, feb);
    this.mar = mar;
  }

  total() {
    return super.sum() + this.mar;
  }

  delete() {
    delete super.sum;
  }
}

let jieun = new UpdateExpenditure("jieun", 60, 70, 50);

jieun.sum(); // (1)
jieun.total(); // (2)
jieun.delete(); // (3)
```
### 답안 작성
```
(3)
super 속성은 delete 연산자를 사용할 수 없으며, 
super.prop 또는 super[expr] 표현식을 사용하여 부모 클래스의 속성을 삭제할 경우 ReferenceError 오류가 발생합니다.
```

- 🔗 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/super

<br>

## 📌문제4
### 다음 코드의 실행 결과를 작성하시오
```js
class Regtangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Regtangle {
  constructor(width) {
    super(width, width);
  }

  getArea() {
    return super.getArea();
  }
}

const regtangle = new Regtangle(2, 5);
const square = new Square(3);

console.log(regtangle.getArea());     // (1)
console.log(square.getArea());        // (2)

Regtangle.prototype.getArea = function() {
  return 999;
}

console.log(regtangle.getArea());     // (3)
console.log(square.getArea());        // (4)
```
### 정답 및 해설
```
(1) : 10
(2) : 9
(3) : 999
(4) : 999
부모 클래스의 프로토타입 메서드를 변경하면 해당 메서드를 참조하던 자식 클래스에서도 변경된다.
```

<br>

## 📌문제5
### 다음 보기 문장의 `참`인 문장을 모두 고르시오.
### 보기
```
(1) : JavaScript는 프로토타입 기반 언어로 ES6 이전까지 클래스 개념 구현이 불가능했다.
(2) : 클래스 기반의 언어와 다르게 JavaScript에서는 인스턴스에서도 직접 메서드를 정의할 수 있다.
(3) : 프로토타입 메서드는 인스턴스에 정의한 메서드를 지칭한다.
```
### 정답 및 해설
```
True는 (2) 입니다.
(1) : ES6이전까지는 프로토타입을 통해 클래스를 구현하고 프로토타입 체이닝을 통해 클래스 상속을 구현했다. P181
(2) : 인스턴스에서 직접 메서드를 정의가능하므로 클래스 개념에 있던 인스턴스 메서드 뜻을 혼란스럽게 만들었다. P178
(3) : 프로토타입 메서드는 프로토타입에 정의한 메서드를 지칭한다. 참고로 클래스 기반 언어(예: JAVA)에서 클래스의 static이 없는 메서드를 인스턴스 메서드라고 부른다. P178-179
```

<br> 

## 📌문제6
### 교재에서 다음 보기와 같은 방법으로 ES5의 `클래스 상속 및 추상화 방법`을 설명하고 있습니다. 이를 통해 공통적인 원리를 작성해주세요.
### 정답 및 해설
```
자식 클래스의 prototype의 __proto__가 부모 클래스의 prototype을 참조하게 만들고, 자식 클래스의 prototype 안에 불필요한 인스턴스 속성을 제거하는 것 입니다.
```

<br>
